diff --git a/README.md b/README.md
index ead2f61..1bd64f0 100644
--- a/README.md
+++ b/README.md
@@ -1,8 +1,8 @@
-# 5 - Logging app events
+# 6 - Using Pub/Sub
 
-This folder contains the sample code for the [Logging app events][step-5]
+This folder contains the sample code for the [Using Pub/Sub][step-6]
 tutorial. Please refer to the tutorial for instructions on configuring, running,
 and deploying this sample.
 
-[step-5]: https://cloud.google.com/php/getting-started/logging-application-events
+[step-6]: https://cloud.google.com/php/getting-started/using-pub-sub
 
diff --git a/app.yaml b/app.yaml
index 700b465..bef3f23 100644
--- a/app.yaml
+++ b/app.yaml
@@ -4,6 +4,12 @@ env: flex
 runtime_config:
   document_root: web
 
+# [START overrides]
+env_variables:
+  NGINX_CONF_INCLUDE: config/nginx-app.conf
+  PHP_INI_OVERRIDE: config/php-app.ini
+# [END overrides]
+
 ## Uncomment for Cloud SQL
 # beta_settings:
 #   cloud_sql_instances: "INSTANCE_CONNECTION_NAME"
diff --git a/bin/pubsub/entrypoint.php b/bin/pubsub/entrypoint.php
new file mode 100644
index 0000000..0b9efb7
--- /dev/null
+++ b/bin/pubsub/entrypoint.php
@@ -0,0 +1,25 @@
+<?php
+/*
+ * Copyright 2015 Google Inc. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+require_once __DIR__ . '/../../vendor/autoload.php';
+
+/** @var Silex\Application $app */
+$app = require __DIR__ . '/../../src/app.php';
+
+/** @var Ratchet\Server\IoServer $server */
+$server = $app['pubsub.server'];
+$server->run();
diff --git a/composer.json b/composer.json
index 4dcaf60..35f26f1 100644
--- a/composer.json
+++ b/composer.json
@@ -11,7 +11,8 @@
     "monolog/monolog": "^1.17",
     "silex/silex": "^1.3",
     "symfony/yaml": "^3.0",
-    "twig/twig": "^1.22"
+    "twig/twig": "^1.22",
+    "cboden/ratchet": " 0.3.*"
   },
   "require-dev": {
     "behat/mink": "^1.7",
diff --git a/composer.lock b/composer.lock
index c25bf35..39f7f44 100644
--- a/composer.lock
+++ b/composer.lock
@@ -4,9 +4,105 @@
         "Read more about it at https://getcomposer.org/doc/01-basic-usage.md#composer-lock-the-lock-file",
         "This file is @generated automatically"
     ],
-    "content-hash": "a1c6ded1cda37463fb5abc1d91ecfcdf",
+    "content-hash": "4e5fe67a15dc445e473d7c1fc84f294f",
     "packages": [
         {
+            "name": "cboden/ratchet",
+            "version": "v0.3.6",
+            "source": {
+                "type": "git",
+                "url": "https://github.com/ratchetphp/Ratchet.git",
+                "reference": "84df35d2a6576985b9e81b564d3c25809f8d647e"
+            },
+            "dist": {
+                "type": "zip",
+                "url": "https://api.github.com/repos/ratchetphp/Ratchet/zipball/84df35d2a6576985b9e81b564d3c25809f8d647e",
+                "reference": "84df35d2a6576985b9e81b564d3c25809f8d647e",
+                "shasum": ""
+            },
+            "require": {
+                "guzzle/http": "^3.6",
+                "php": ">=5.3.9",
+                "react/socket": "^0.3 || ^0.4",
+                "symfony/http-foundation": "^2.2|^3.0",
+                "symfony/routing": "^2.2|^3.0"
+            },
+            "type": "library",
+            "autoload": {
+                "psr-4": {
+                    "Ratchet\\": "src/Ratchet"
+                }
+            },
+            "notification-url": "https://packagist.org/downloads/",
+            "license": [
+                "MIT"
+            ],
+            "authors": [
+                {
+                    "name": "Chris Boden",
+                    "email": "cboden@gmail.com",
+                    "role": "Developer"
+                }
+            ],
+            "description": "PHP WebSocket library",
+            "homepage": "http://socketo.me",
+            "keywords": [
+                "Ratchet",
+                "WebSockets",
+                "server",
+                "sockets"
+            ],
+            "time": "2017-01-06T14:36:36+00:00"
+        },
+        {
+            "name": "evenement/evenement",
+            "version": "v2.1.0",
+            "source": {
+                "type": "git",
+                "url": "https://github.com/igorw/evenement.git",
+                "reference": "6ba9a777870ab49f417e703229d53931ed40fd7a"
+            },
+            "dist": {
+                "type": "zip",
+                "url": "https://api.github.com/repos/igorw/evenement/zipball/6ba9a777870ab49f417e703229d53931ed40fd7a",
+                "reference": "6ba9a777870ab49f417e703229d53931ed40fd7a",
+                "shasum": ""
+            },
+            "require": {
+                "php": ">=5.4.0"
+            },
+            "require-dev": {
+                "phpunit/phpunit": "^6.0||^5.7||^4.8.35"
+            },
+            "type": "library",
+            "extra": {
+                "branch-alias": {
+                    "dev-master": "2.0-dev"
+                }
+            },
+            "autoload": {
+                "psr-0": {
+                    "Evenement": "src"
+                }
+            },
+            "notification-url": "https://packagist.org/downloads/",
+            "license": [
+                "MIT"
+            ],
+            "authors": [
+                {
+                    "name": "Igor Wiedler",
+                    "email": "igor@wiedler.ch"
+                }
+            ],
+            "description": "Événement is a very simple event dispatching library for PHP",
+            "keywords": [
+                "event-dispatcher",
+                "event-emitter"
+            ],
+            "time": "2017-07-17T17:39:19+00:00"
+        },
+        {
             "name": "firebase/php-jwt",
             "version": "v4.0.0",
             "source": {
@@ -281,6 +377,208 @@
             "time": "2017-02-23T20:14:16+00:00"
         },
         {
+            "name": "guzzle/common",
+            "version": "v3.9.2",
+            "target-dir": "Guzzle/Common",
+            "source": {
+                "type": "git",
+                "url": "https://github.com/Guzzle3/common.git",
+                "reference": "2e36af7cf2ce3ea1f2d7c2831843b883a8e7b7dc"
+            },
+            "dist": {
+                "type": "zip",
+                "url": "https://api.github.com/repos/Guzzle3/common/zipball/2e36af7cf2ce3ea1f2d7c2831843b883a8e7b7dc",
+                "reference": "2e36af7cf2ce3ea1f2d7c2831843b883a8e7b7dc",
+                "shasum": ""
+            },
+            "require": {
+                "php": ">=5.3.2",
+                "symfony/event-dispatcher": ">=2.1"
+            },
+            "type": "library",
+            "extra": {
+                "branch-alias": {
+                    "dev-master": "3.7-dev"
+                }
+            },
+            "autoload": {
+                "psr-0": {
+                    "Guzzle\\Common": ""
+                }
+            },
+            "notification-url": "https://packagist.org/downloads/",
+            "license": [
+                "MIT"
+            ],
+            "description": "Common libraries used by Guzzle",
+            "homepage": "http://guzzlephp.org/",
+            "keywords": [
+                "collection",
+                "common",
+                "event",
+                "exception"
+            ],
+            "abandoned": "guzzle/guzzle",
+            "time": "2014-08-11T04:32:36+00:00"
+        },
+        {
+            "name": "guzzle/http",
+            "version": "v3.9.2",
+            "target-dir": "Guzzle/Http",
+            "source": {
+                "type": "git",
+                "url": "https://github.com/Guzzle3/http.git",
+                "reference": "1e8dd1e2ba9dc42332396f39fbfab950b2301dc5"
+            },
+            "dist": {
+                "type": "zip",
+                "url": "https://api.github.com/repos/Guzzle3/http/zipball/1e8dd1e2ba9dc42332396f39fbfab950b2301dc5",
+                "reference": "1e8dd1e2ba9dc42332396f39fbfab950b2301dc5",
+                "shasum": ""
+            },
+            "require": {
+                "guzzle/common": "self.version",
+                "guzzle/parser": "self.version",
+                "guzzle/stream": "self.version",
+                "php": ">=5.3.2"
+            },
+            "suggest": {
+                "ext-curl": "*"
+            },
+            "type": "library",
+            "extra": {
+                "branch-alias": {
+                    "dev-master": "3.7-dev"
+                }
+            },
+            "autoload": {
+                "psr-0": {
+                    "Guzzle\\Http": ""
+                }
+            },
+            "notification-url": "https://packagist.org/downloads/",
+            "license": [
+                "MIT"
+            ],
+            "authors": [
+                {
+                    "name": "Michael Dowling",
+                    "email": "mtdowling@gmail.com",
+                    "homepage": "https://github.com/mtdowling"
+                }
+            ],
+            "description": "HTTP libraries used by Guzzle",
+            "homepage": "http://guzzlephp.org/",
+            "keywords": [
+                "Guzzle",
+                "client",
+                "curl",
+                "http",
+                "http client"
+            ],
+            "abandoned": "guzzle/guzzle",
+            "time": "2014-08-11T04:32:36+00:00"
+        },
+        {
+            "name": "guzzle/parser",
+            "version": "v3.9.2",
+            "target-dir": "Guzzle/Parser",
+            "source": {
+                "type": "git",
+                "url": "https://github.com/Guzzle3/parser.git",
+                "reference": "6874d171318a8e93eb6d224cf85e4678490b625c"
+            },
+            "dist": {
+                "type": "zip",
+                "url": "https://api.github.com/repos/Guzzle3/parser/zipball/6874d171318a8e93eb6d224cf85e4678490b625c",
+                "reference": "6874d171318a8e93eb6d224cf85e4678490b625c",
+                "shasum": ""
+            },
+            "require": {
+                "php": ">=5.3.2"
+            },
+            "type": "library",
+            "extra": {
+                "branch-alias": {
+                    "dev-master": "3.7-dev"
+                }
+            },
+            "autoload": {
+                "psr-0": {
+                    "Guzzle\\Parser": ""
+                }
+            },
+            "notification-url": "https://packagist.org/downloads/",
+            "license": [
+                "MIT"
+            ],
+            "description": "Interchangeable parsers used by Guzzle",
+            "homepage": "http://guzzlephp.org/",
+            "keywords": [
+                "URI Template",
+                "cookie",
+                "http",
+                "message",
+                "url"
+            ],
+            "abandoned": "guzzle/guzzle",
+            "time": "2014-02-05T18:29:46+00:00"
+        },
+        {
+            "name": "guzzle/stream",
+            "version": "v3.9.2",
+            "target-dir": "Guzzle/Stream",
+            "source": {
+                "type": "git",
+                "url": "https://github.com/Guzzle3/stream.git",
+                "reference": "60c7fed02e98d2c518dae8f97874c8f4622100f0"
+            },
+            "dist": {
+                "type": "zip",
+                "url": "https://api.github.com/repos/Guzzle3/stream/zipball/60c7fed02e98d2c518dae8f97874c8f4622100f0",
+                "reference": "60c7fed02e98d2c518dae8f97874c8f4622100f0",
+                "shasum": ""
+            },
+            "require": {
+                "guzzle/common": "self.version",
+                "php": ">=5.3.2"
+            },
+            "suggest": {
+                "guzzle/http": "To convert Guzzle request objects to PHP streams"
+            },
+            "type": "library",
+            "extra": {
+                "branch-alias": {
+                    "dev-master": "3.7-dev"
+                }
+            },
+            "autoload": {
+                "psr-0": {
+                    "Guzzle\\Stream": ""
+                }
+            },
+            "notification-url": "https://packagist.org/downloads/",
+            "license": [
+                "MIT"
+            ],
+            "authors": [
+                {
+                    "name": "Michael Dowling",
+                    "email": "mtdowling@gmail.com",
+                    "homepage": "https://github.com/mtdowling"
+                }
+            ],
+            "description": "Guzzle stream wrapper component",
+            "homepage": "http://guzzlephp.org/",
+            "keywords": [
+                "Guzzle",
+                "component",
+                "stream"
+            ],
+            "abandoned": "guzzle/guzzle",
+            "time": "2014-05-01T21:36:02+00:00"
+        },
+        {
             "name": "guzzlehttp/guzzle",
             "version": "6.3.0",
             "source": {
@@ -821,6 +1119,180 @@
             "time": "2016-10-10T12:19:37+00:00"
         },
         {
+            "name": "react/event-loop",
+            "version": "v0.4.3",
+            "source": {
+                "type": "git",
+                "url": "https://github.com/reactphp/event-loop.git",
+                "reference": "8bde03488ee897dc6bb3d91e4e17c353f9c5252f"
+            },
+            "dist": {
+                "type": "zip",
+                "url": "https://api.github.com/repos/reactphp/event-loop/zipball/8bde03488ee897dc6bb3d91e4e17c353f9c5252f",
+                "reference": "8bde03488ee897dc6bb3d91e4e17c353f9c5252f",
+                "shasum": ""
+            },
+            "require": {
+                "php": ">=5.4.0"
+            },
+            "require-dev": {
+                "phpunit/phpunit": "~4.8"
+            },
+            "suggest": {
+                "ext-event": "~1.0",
+                "ext-libev": "*",
+                "ext-libevent": ">=0.1.0"
+            },
+            "type": "library",
+            "autoload": {
+                "psr-4": {
+                    "React\\EventLoop\\": "src"
+                }
+            },
+            "notification-url": "https://packagist.org/downloads/",
+            "license": [
+                "MIT"
+            ],
+            "description": "Event loop abstraction layer that libraries can use for evented I/O.",
+            "keywords": [
+                "asynchronous",
+                "event-loop"
+            ],
+            "time": "2017-04-27T10:56:23+00:00"
+        },
+        {
+            "name": "react/promise",
+            "version": "v2.5.1",
+            "source": {
+                "type": "git",
+                "url": "https://github.com/reactphp/promise.git",
+                "reference": "62785ae604c8d69725d693eb370e1d67e94c4053"
+            },
+            "dist": {
+                "type": "zip",
+                "url": "https://api.github.com/repos/reactphp/promise/zipball/62785ae604c8d69725d693eb370e1d67e94c4053",
+                "reference": "62785ae604c8d69725d693eb370e1d67e94c4053",
+                "shasum": ""
+            },
+            "require": {
+                "php": ">=5.4.0"
+            },
+            "require-dev": {
+                "phpunit/phpunit": "~4.8"
+            },
+            "type": "library",
+            "autoload": {
+                "psr-4": {
+                    "React\\Promise\\": "src/"
+                },
+                "files": [
+                    "src/functions_include.php"
+                ]
+            },
+            "notification-url": "https://packagist.org/downloads/",
+            "license": [
+                "MIT"
+            ],
+            "authors": [
+                {
+                    "name": "Jan Sorgalla",
+                    "email": "jsorgalla@gmail.com"
+                }
+            ],
+            "description": "A lightweight implementation of CommonJS Promises/A for PHP",
+            "keywords": [
+                "promise",
+                "promises"
+            ],
+            "time": "2017-03-25T12:08:31+00:00"
+        },
+        {
+            "name": "react/socket",
+            "version": "v0.4.6",
+            "source": {
+                "type": "git",
+                "url": "https://github.com/reactphp/socket.git",
+                "reference": "cf074e53c974df52388ebd09710a9018894745d2"
+            },
+            "dist": {
+                "type": "zip",
+                "url": "https://api.github.com/repos/reactphp/socket/zipball/cf074e53c974df52388ebd09710a9018894745d2",
+                "reference": "cf074e53c974df52388ebd09710a9018894745d2",
+                "shasum": ""
+            },
+            "require": {
+                "evenement/evenement": "~2.0|~1.0",
+                "php": ">=5.3.0",
+                "react/event-loop": "0.4.*|0.3.*",
+                "react/promise": "^2.0 || ^1.1",
+                "react/stream": "^0.4.5"
+            },
+            "require-dev": {
+                "clue/block-react": "^1.1",
+                "phpunit/phpunit": "~4.8",
+                "react/socket-client": "^0.5.1"
+            },
+            "type": "library",
+            "autoload": {
+                "psr-4": {
+                    "React\\Socket\\": "src"
+                }
+            },
+            "notification-url": "https://packagist.org/downloads/",
+            "license": [
+                "MIT"
+            ],
+            "description": "Async, streaming plaintext TCP/IP and secure TLS socket server for React PHP",
+            "keywords": [
+                "Socket"
+            ],
+            "time": "2017-01-26T09:23:38+00:00"
+        },
+        {
+            "name": "react/stream",
+            "version": "v0.4.6",
+            "source": {
+                "type": "git",
+                "url": "https://github.com/reactphp/stream.git",
+                "reference": "44dc7f51ea48624110136b535b9ba44fd7d0c1ee"
+            },
+            "dist": {
+                "type": "zip",
+                "url": "https://api.github.com/repos/reactphp/stream/zipball/44dc7f51ea48624110136b535b9ba44fd7d0c1ee",
+                "reference": "44dc7f51ea48624110136b535b9ba44fd7d0c1ee",
+                "shasum": ""
+            },
+            "require": {
+                "evenement/evenement": "^2.0|^1.0",
+                "php": ">=5.3.8"
+            },
+            "require-dev": {
+                "clue/stream-filter": "~1.2",
+                "react/event-loop": "^0.4|^0.3",
+                "react/promise": "^2.0|^1.0"
+            },
+            "suggest": {
+                "react/event-loop": "^0.4",
+                "react/promise": "^2.0"
+            },
+            "type": "library",
+            "autoload": {
+                "psr-4": {
+                    "React\\Stream\\": "src"
+                }
+            },
+            "notification-url": "https://packagist.org/downloads/",
+            "license": [
+                "MIT"
+            ],
+            "description": "Basic readable and writable stream interfaces that support piping.",
+            "keywords": [
+                "pipe",
+                "stream"
+            ],
+            "time": "2017-01-25T14:44:14+00:00"
+        },
+        {
             "name": "rize/uri-template",
             "version": "0.3.2",
             "source": {
diff --git a/nginx-app.conf b/config/nginx-app.conf
similarity index 100%
rename from nginx-app.conf
rename to config/nginx-app.conf
diff --git a/php.ini b/config/php-app.ini
similarity index 100%
rename from php.ini
rename to config/php-app.ini
diff --git a/config/php-pubsub.ini b/config/php-pubsub.ini
new file mode 100644
index 0000000..1f0dd17
--- /dev/null
+++ b/config/php-pubsub.ini
@@ -0,0 +1,3 @@
+extension=mongo.so
+extension=curl.so
+suhosin.executor.func.blacklist=
\ No newline at end of file
diff --git a/config/settings.yml.dist b/config/settings.yml.dist
index 4526a43..4d7c037 100644
--- a/config/settings.yml.dist
+++ b/config/settings.yml.dist
@@ -17,3 +17,6 @@ cloudsql_port: 3306
 mongo_url: YOUR_MONGODB_URL
 mongo_database: YOUR_MONGO_DATABASE
 mongo_collection: YOUR_MONGO_COLLECTION
+
+pubsub_topic_name: book-created-or-updated
+pubsub_subscription_name: fill-book-details
diff --git a/src/PubSub/AsyncConnection.php b/src/PubSub/AsyncConnection.php
new file mode 100644
index 0000000..ea14436
--- /dev/null
+++ b/src/PubSub/AsyncConnection.php
@@ -0,0 +1,70 @@
+<?php
+
+namespace Google\Cloud\Samples\Bookshelf\PubSub;
+
+use Google\Auth\HttpHandler\HttpHandlerFactory;
+use Google\Cloud\PubSub\Connection\Rest;
+use Google\Cloud\PubSub\PubSubClient;
+use Google\Cloud\RequestWrapper;
+use Google\Cloud\RestTrait;
+use GuzzleHttp\Client;
+use GuzzleHttp\HandlerStack;
+use GuzzleHttp\Handler\CurlMultiHandler;
+
+/**
+ * Class AsyncConnection makes async calls to the PubSub API
+ */
+class AsyncConnection extends Rest
+{
+    use RestTrait;
+
+    private $handler;
+
+    public function __construct()
+    {
+        // call parent constructor
+        parent::__construct();
+
+        // create the asyncronous curl handler
+        $this->handler = new CurlMultiHandler;
+        $httpClient = new Client([
+            'handler' => HandlerStack::create($this->handler)
+        ]);
+        // have the request wrapper call guzzle asyncronously
+        $this->setRequestWrapper(new RequestWrapper([
+            'scopes' => PubSubClient::FULL_CONTROL_SCOPE,
+            'httpHandler' =>
+                function ($request, $options = []) use ($httpClient) {
+                    return $httpClient->sendAsync($request, $options);
+                },
+            'authHttpHandler' => HttpHandlerFactory::build(),
+        ]));
+    }
+
+    /**
+     * Delivers an asyncronous request to a pubsub subscroption
+     *
+     * @param array $options
+     * @return GuzzleHttp\Promise\Promise
+     */
+    public function pull(array $options)
+    {
+        $requestOptions = array_intersect_key($options, [
+            'httpOptions' => null,
+            'retries' => null,
+        ]);
+
+        $request = $this->requestBuilder->build('subscriptions', 'pull', $options);
+
+        return $this->requestWrapper->send(
+            $request,
+            $requestOptions
+        );
+    }
+
+    public function tick()
+    {
+        // advance the curl event loop
+        return $this->handler->tick();
+    }
+}
diff --git a/src/PubSub/HealthCheckListener.php b/src/PubSub/HealthCheckListener.php
new file mode 100644
index 0000000..81f1d96
--- /dev/null
+++ b/src/PubSub/HealthCheckListener.php
@@ -0,0 +1,53 @@
+<?php
+
+namespace Google\Cloud\Samples\Bookshelf\PubSub;
+
+use Guzzle\Http\Message\RequestInterface;
+use Guzzle\Http\Message\Response;
+use Psr\Log\LoggerInterface;
+use Ratchet\Http\HttpServerInterface;
+use Ratchet\ConnectionInterface;
+
+/**
+ * Class HealthCheckListener responds to the App Engine health checker
+ */
+class HealthCheckListener implements HttpServerInterface
+{
+    private $logger;
+
+    public function __construct(LoggerInterface $logger = null)
+    {
+        $this->logger = $logger;
+    }
+
+    // [START open]
+    public function onOpen(ConnectionInterface $conn, RequestInterface $request = null)
+    {
+        // send the 200 OK health response and return
+        $response = new Response(200, [], 'Pubsub worker is running!');
+        $conn->send((string) $response);
+        $conn->close();
+    }
+    // [END open]
+
+    public function onMessage(ConnectionInterface $from, $msg)
+    {
+    }
+
+    public function onClose(ConnectionInterface $conn)
+    {
+    }
+
+    public function onError(ConnectionInterface $conn, \Exception $e)
+    {
+        $this->log(sprintf('An error has occurred: %s', $e->getMessage()));
+        $conn->close();
+    }
+
+    private function log($message)
+    {
+        if ($this->logger) {
+            $this->logger->error($message);
+        }
+    }
+}
diff --git a/src/PubSub/LookupBookDetailsJob.php b/src/PubSub/LookupBookDetailsJob.php
new file mode 100644
index 0000000..4df12b9
--- /dev/null
+++ b/src/PubSub/LookupBookDetailsJob.php
@@ -0,0 +1,49 @@
+<?php
+
+namespace Google\Cloud\Samples\Bookshelf\PubSub;
+
+use Google\Cloud\Samples\Bookshelf\DataModel\DataModelInterface;
+use Google_Client;
+use Google_Service_Books;
+
+/**
+ * Class LookupBookDetailsJob looks up book details using the Google API PHP
+ * Client.
+ */
+class LookupBookDetailsJob
+{
+    private $model;
+    private $client;
+
+    public function __construct(DataModelInterface $model, Google_Client $client)
+    {
+        $this->model = $model;
+        $this->client = $client;
+    }
+
+    public function work($id)
+    {
+        if ($book = $this->model->read($id)) {
+            // [START lookup_books]
+            $service = new Google_Service_Books($this->client);
+            $options = ['orderBy' => 'relevance'];
+            $results = $service->volumes->listVolumes($book['title'], $options);
+            // [END lookup_books]
+            // [START update_image]
+            foreach ($results as $result) {
+                $volumeInfo = $result->getVolumeInfo();
+                $imageInfo = $volumeInfo->getImageLinks();
+                if ($thumbnail = $imageInfo->getThumbnail()) {
+                    $book['image_url'] = $thumbnail;
+                    $this->client->getLogger()->info(sprintf(
+                        'Updating book "%s" with thumbnail "%s"',
+                        $id, basename($thumbnail)));
+                    return $this->model->update($book);
+                }
+            }
+            // [END update_image]
+        }
+
+        return false;
+    }
+}
diff --git a/src/PubSub/Worker.php b/src/PubSub/Worker.php
new file mode 100644
index 0000000..82fbf6e
--- /dev/null
+++ b/src/PubSub/Worker.php
@@ -0,0 +1,72 @@
+<?php
+
+namespace Google\Cloud\Samples\Bookshelf\PubSub;
+
+use Google\Cloud\PubSub\Subscription;
+use Google\Cloud\PubSub\Message;
+use Psr\Log\LoggerInterface;
+
+/**
+ * Class Worker calls the PubSub API and runs a job when work is received.
+ */
+class Worker
+{
+    private $callback;
+    private $connection;
+    private $promise;
+    private $subscription;
+
+    public function __construct(Subscription $subscription, $job, LoggerInterface $logger)
+    {
+        // [START callback]
+        $callback = function ($response) use ($job, $subscription, $logger) {
+            $ackMessages = [];
+            $messages = json_decode($response->getBody(), true);
+            if (isset($messages['receivedMessages'])) {
+                foreach ($messages['receivedMessages'] as $message) {
+                    $pubSubMessage = new Message($message['message'], array('ackId' => $message['ackId']));
+                    $attributes = $pubSubMessage->attributes();
+                    $logger->info(sprintf('Message received for book ID "%s" ', $attributes['id']));
+                    // Do the actual work in the LookupBookDetailsJob class
+                    $job->work($attributes['id']);
+                    $ackMessages[] = $pubSubMessage;
+                }
+            }
+            // Acknowledge the messsages have been handled
+            if (!empty($ackMessages)) {
+                $subscription->acknowledgeBatch($ackMessages);
+            }
+        };
+        // [END callback]
+        $this->callback = $callback;
+        $this->subscription = $subscription;
+        $this->connection = new AsyncConnection();
+    }
+
+    public function __invoke($timer)
+    {
+        // advance the event loop for our async call to pubsub
+        $this->connection->tick();
+
+        // check the status of the promise and handle completion or error
+        if (!$this->promise || 'fulfilled' == $state = $this->promise->getState()) {
+            $this->asyncPubsubPull();
+        } elseif ('rejected' == $state) {
+            // this will throw the exception and stop the event loop
+            $this->promise->wait();
+        }
+    }
+
+    private function asyncPubsubPull()
+    {
+        $callback = $this->callback;
+        // [START promise]
+        $promise = $this->connection->pull([
+            'maxMessages' => 1000,
+            'subscription' => $this->subscription->info()['name'],
+        ]);
+        $promise->then($callback);
+        // [END promise]
+        $this->promise = $promise;
+    }
+}
diff --git a/src/app.php b/src/app.php
index 8e49c0c..5a505b3 100644
--- a/src/app.php
+++ b/src/app.php
@@ -21,10 +21,22 @@
  * Follows Silex Skeleton pattern.
  */
 use Google\Cloud\Logger\AppEngineFlexHandler;
+// [START pubsub_client]
+use Google\Cloud\PubSub\PubSubClient;
+// [END pubsub_client]
 use Google\Cloud\Samples\Bookshelf\DataModel\Sql;
 use Google\Cloud\Samples\Bookshelf\DataModel\Datastore;
 use Google\Cloud\Samples\Bookshelf\DataModel\MongoDb;
 use Google\Cloud\Samples\Bookshelf\FileSystem\CloudStorage;
+// [START add_worker_ns]
+use Google\Cloud\Samples\Bookshelf\PubSub\LookupBookDetailsJob;
+use Google\Cloud\Samples\Bookshelf\PubSub\Worker;
+// [END add_worker_ns]
+// [START pubsub_server_ns]
+use Google\Cloud\Samples\Bookshelf\PubSub\HealthCheckListener;
+use Ratchet\Http\HttpServer;
+use Ratchet\Server\IoServer;
+// [END pubsub_server_ns]
 use Silex\Application;
 use Silex\Provider\SessionServiceProvider;
 use Silex\Provider\TwigServiceProvider;
@@ -76,19 +88,78 @@ if (isset($_SERVER['GAE_VM']) && $_SERVER['GAE_VM'] === 'true') {
 // create the google authorization client
 // [START google_client]
 $app['google_client'] = function ($app) {
-    /** @var Symfony\Component\Routing\Generator\UrlGenerator $urlGen */
-    $urlGen = $app['url_generator'];
-    $redirectUri = $urlGen->generate('login_callback', [], $urlGen::ABSOLUTE_URL);
     $client = new Google_Client([
         'client_id'     => $app['config']['google_client_id'],
         'client_secret' => $app['config']['google_client_secret'],
-        'redirect_uri'  => $redirectUri,
     ]);
     $client->setLogger($app['monolog']);
+    if ($app['routes']->get('login_callback')) {
+        /** @var Symfony\Component\Routing\Generator\UrlGenerator $urlGen */
+        $urlGen = $app['url_generator'];
+        $redirectUri = $urlGen->generate('login_callback', [], $urlGen::ABSOLUTE_URL);
+        $client->setRedirectUri($redirectUri);
+    }
     return $client;
 };
 // [END google_client]
 
+// [START pubsub_client]
+$app['pubsub.client'] = function ($app) {
+    // create the pubsub client
+    $projectId = $app['config']['google_project_id'];
+    $pubsub = new PubSubClient([
+        'projectId' => $projectId,
+    ]);
+    return $pubsub;
+};
+// [END pubsub_client]
+
+// [START pubsub_topic]
+$app['pubsub.topic'] = function ($app) {
+    // create the topic if it does not exist.
+    /** @var Google\Cloud\PubSub\PubSubClient **/
+    $pubsub = $app['pubsub.client'];
+    $topicName = $app['config']['pubsub_topic_name'];
+    $topic = $pubsub->topic($topicName);
+    if (!$topic->exists()) {
+        $topic->create();
+    }
+    return $topic;
+};
+// [END pubsub_topic]
+
+$app['pubsub.subscription'] = function ($app) {
+    // create the subscription if it does not exist.
+    /** @var Google\Cloud\PubSub\Topic $topic **/
+    $topic = $app['pubsub.topic'];
+    $subName = $app['config']['pubsub_subscription_name'];
+    $subscription = $topic->subscription($subName);
+    if (!$subscription->exists()) {
+        $subscription->create();
+    }
+    return $subscription;
+};
+
+$app['pubsub.server'] = function ($app) {
+    /** @var Monolog\Logger $logger **/
+    $logger = $app['monolog'];
+    // [START pubsub_server]
+    // Listen to port 8080 for our health checker
+    $server = IoServer::factory(
+        new HttpServer(new HealthCheckListener($logger)),
+        8080
+    );
+    // [END pubsub_server]
+    // [START add_worker]
+    // create the job and worker
+    $job = new LookupBookDetailsJob($app['bookshelf.model'], $app['google_client']);
+    $worker = new Worker($app['pubsub.subscription'], $job, $logger);
+    // add our worker to the event loop
+    $server->loop->addPeriodicTimer(0, $worker);
+    // [END add_worker]
+    return $server;
+};
+
 // Cloud Storage
 $app['bookshelf.storage'] = function ($app) {
     /** @var array $config */
diff --git a/src/controllers.php b/src/controllers.php
index 79a3b78..ecbb13d 100644
--- a/src/controllers.php
+++ b/src/controllers.php
@@ -75,7 +75,19 @@ $app->post('/books/add', function (Request $request) use ($app) {
         $book['created_by'] = $app['user']['name'];
         $book['created_by_id'] = $app['user']['id'];
     }
-    $id = $model->create($book);
+
+    # [START publish_topic]
+    if ($id = $model->create($book)) {
+        /** @var Google\Cloud\PubSub\PubSub\Topic $topic */
+        $topic = $app['pubsub.topic'];
+        $topic->publish([
+            'data' => 'Updated Book',
+            'attributes' => [
+                'id' => $id
+            ]
+        ]);
+    }
+    # [END publish_topic]
 
     return $app->redirect("/books/$id");
 });
@@ -134,6 +146,15 @@ $app->post('/books/{id}/edit', function (Request $request, $id) use ($app) {
     }
     // [END add_image]
     if ($model->update($book)) {
+        /** @var Google\Cloud\PubSub\Topic $topic */
+        $topic = $app['pubsub.topic'];
+        $topic->publish([
+            'data' => 'Edit Book',
+            'attributes' => [
+                'id' => $id
+            ]
+        ]);
+
         return $app->redirect("/books/$id");
     }
 
diff --git a/test/app-e2e.yaml b/test/app-e2e.yaml
index 574ebd5..8dffa4d 100644
--- a/test/app-e2e.yaml
+++ b/test/app-e2e.yaml
@@ -6,6 +6,8 @@ runtime_config:
 
 env_variables:
   BOOKSHELF_CONFIG: /app/config/settings-e2e.yml
+  NGINX_CONF_INCLUDE: config/nginx-app.conf
+  PHP_INI_OVERRIDE: config/php-app.ini
 
 manual_scaling:
   instances: 1
diff --git a/test/functional/AppTest.php b/test/functional/AppTest.php
index 56d7200..6d7b373 100644
--- a/test/functional/AppTest.php
+++ b/test/functional/AppTest.php
@@ -139,4 +139,11 @@ class AppTest extends WebTestCase
 
         $model = $this->app['bookshelf.model'];
     }
+
+    public function testPubsubServer()
+    {
+        // smoke test
+        $server = $this->app['pubsub.server'];
+        $server->loop->tick();
+    }
 }
diff --git a/test/lib/GetConfigTrait.php b/test/lib/GetConfigTrait.php
index 1aa3b66..2889ce6 100644
--- a/test/lib/GetConfigTrait.php
+++ b/test/lib/GetConfigTrait.php
@@ -38,6 +38,8 @@ trait GetConfigTrait
             'mongo_url' => getenv('MONGO_URL'),
             'mongo_database' => getenv('MONGO_DATABASE'),
             'mongo_collection' => getenv('MONGO_COLLECTION'),
+            'pubsub_topic_name' => getenv('PUBSUB_TOPIC_NAME'),
+            'pubsub_subscription_name' => getenv('PUBSUB_SUBSCRIPTION_NAME'),
         );
 
         // if a local config exists, use it
diff --git a/test/unit/PubSub/AsyncConnectionTest.php b/test/unit/PubSub/AsyncConnectionTest.php
new file mode 100644
index 0000000..f8e6d5a
--- /dev/null
+++ b/test/unit/PubSub/AsyncConnectionTest.php
@@ -0,0 +1,52 @@
+<?php
+/*
+ * Copyright 2015 Google Inc. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+namespace Google\Cloud\Samples\Bookshelf\PubSub;
+
+class AsyncConnectionTest extends \PHPUnit_Framework_TestCase
+{
+    public function testPull()
+    {
+        $connection = new AsyncConnection();
+        $requestWrapper = $this->getMockBuilder('Google\Cloud\RequestWrapper')
+            ->disableOriginalConstructor()
+            ->getMock();
+        $requestWrapper->expects($this->once())
+            ->method('send');
+        $connection->setRequestWrapper($requestWrapper);
+
+        $connection->pull([]);
+    }
+
+    public function testTick()
+    {
+        $handler = $this->getMockBuilder('GuzzleHttp\Handler\CurlMultiHandler')
+            ->disableOriginalConstructor()
+            ->getMock();
+        $handler->expects($this->once())
+            ->method('tick');
+
+        $connection = new AsyncConnection();
+
+        // set the handler property using ReflectionClass
+        $class = new \ReflectionClass($connection);
+        $property = $class->getProperty('handler');
+        $property->setAccessible(true);
+        $property->setValue($connection, $handler);
+
+        $connection->tick();
+    }
+}
diff --git a/test/unit/PubSub/HealthCheckListenerTest.php b/test/unit/PubSub/HealthCheckListenerTest.php
new file mode 100644
index 0000000..eccb58a
--- /dev/null
+++ b/test/unit/PubSub/HealthCheckListenerTest.php
@@ -0,0 +1,73 @@
+<?php
+/*
+ * Copyright 2015 Google Inc. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+namespace Google\Cloud\Samples\Bookshelf\PubSub;
+
+class HealthCheckListenerTest extends \PHPUnit_Framework_TestCase
+{
+    public function testOnOpen()
+    {
+        $logger = $this->getMockBuilder('Monolog\Logger')
+            ->disableOriginalConstructor()
+            ->getMock();
+        $conn = $this->getMock('Ratchet\ConnectionInterface');
+        $conn->expects($this->once())
+            ->method('send')
+            ->will($this->returnCallback(function ($o) use (&$output) {
+                $output = $o;
+            }));
+        $listener = new HealthCheckListener($logger);
+        $listener->onOpen($conn);
+
+        $this->assertContains('HTTP/1.1 200 OK', $output);
+        $this->assertContains('Pubsub worker is running!', $output);
+    }
+
+    public function testOnError()
+    {
+        $logger = $this->getMockBuilder('Monolog\Logger')
+            ->disableOriginalConstructor()
+            ->getMock();
+        $logger->expects($this->once())
+            ->method('error')
+            ->will($this->returnCallback(function ($m) use (&$message) {
+                $message = $m;
+            }));
+        $conn = $this->getMock('Ratchet\ConnectionInterface');
+        $e = new \Exception('This is the message');
+        $listener = new HealthCheckListener($logger);
+        $listener->onError($conn, $e);
+
+        $this->assertEquals(
+            sprintf('An error has occurred: %s', $e->getMessage()),
+            $message
+        );
+    }
+
+    public function testOnMessage()
+    {
+        $conn = $this->getMock('Ratchet\ConnectionInterface');
+        $listener = new HealthCheckListener();
+        $listener->onMessage($conn, 'unused message');
+    }
+
+    public function testOnClose()
+    {
+        $conn = $this->getMock('Ratchet\ConnectionInterface');
+        $listener = new HealthCheckListener();
+        $listener->onClose($conn);
+    }
+}
diff --git a/test/unit/PubSub/LookupBookDetailsJobTest.php b/test/unit/PubSub/LookupBookDetailsJobTest.php
new file mode 100644
index 0000000..dd41555
--- /dev/null
+++ b/test/unit/PubSub/LookupBookDetailsJobTest.php
@@ -0,0 +1,140 @@
+<?php
+/*
+ * Copyright 2015 Google Inc. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+namespace Google\Cloud\Samples\Bookshelf\PubSub;
+
+class LookupBookDetailsJobTest extends \PHPUnit_Framework_TestCase
+{
+    public function testWork()
+    {
+        $bookId = 123;
+        $volume = new \Google_Service_Books_Volume([
+            'volumeInfo' => [
+                'imageLinks' => ['thumbnail' => 'testImage.jpg']
+            ]
+        ]);
+        $logger = $this->getMockBuilder('Psr\Log\LoggerInterface')->disableOriginalConstructor()->getMock();
+        $client = $this->getMock('Google_Client');
+        $client->expects($this->exactly(2))
+            ->method('getLogger')
+            ->will($this->returnValue($logger));
+        $client->expects($this->once())
+            ->method('execute')
+            ->will($this->returnValue([$volume]));
+        $model = $this->getMock('Google\Cloud\Samples\Bookshelf\DataModel\DataModelInterface');
+        $model->expects($this->once())
+            ->method('read')
+            ->will($this->returnValue([
+                'title' => 'My Book Title',
+            ]));
+        $model->expects($this->once())
+            ->method('update')
+            ->with(['title' => 'My Book Title', 'image_url' => 'testImage.jpg'])
+            ->will($this->returnValue(true));
+
+        $job = new LookupBookDetailsJob($model, $client, $logger);
+        $result = $job->work($bookId);
+        $this->assertTrue($result);
+    }
+
+    public function testNoBookMatch()
+    {
+        $bookId = 123;
+        $logger = $this->getMockBuilder('Psr\Log\LoggerInterface')->disableOriginalConstructor()->getMock();
+        $client = $this->getMock('Google_Client');
+        $client->expects($this->once())
+            ->method('getLogger')
+            ->will($this->returnValue($logger));
+        $client->expects($this->once())
+            ->method('execute')
+            ->will($this->returnValue([]));
+        $model = $this->getMock('Google\Cloud\Samples\Bookshelf\DataModel\DataModelInterface');
+        $model->expects($this->once())
+            ->method('read')
+            ->will($this->returnValue([
+                'title' => 'My Book Title',
+            ]));
+
+        $job = new LookupBookDetailsJob($model, $client);
+        $result = $job->work($bookId);
+        $this->assertFalse($result);
+    }
+
+    public function testNoBookImages()
+    {
+        $bookId = 123;
+        $volume = new \Google_Service_Books_Volume([
+            'volumeInfo' => [
+                'imageLinks' => ['thumbnail' => '']
+            ]
+        ]);
+        $logger = $this->getMockBuilder('Psr\Log\LoggerInterface')->disableOriginalConstructor()->getMock();
+        $client = $this->getMock('Google_Client');
+        $client->expects($this->once())
+            ->method('getLogger')
+            ->will($this->returnValue($logger));
+        $client->expects($this->once())
+            ->method('execute')
+            ->will($this->returnValue([$volume]));
+        $model = $this->getMock('Google\Cloud\Samples\Bookshelf\DataModel\DataModelInterface');
+        $model->expects($this->once())
+            ->method('read')
+            ->will($this->returnValue([
+                'title' => 'My Book Title',
+            ]));
+
+        $job = new LookupBookDetailsJob($model, $client);
+        $result = $job->work($bookId);
+        $this->assertFalse($result);
+    }
+
+    public function testNoBookImageInSecondResult()
+    {
+        $bookId = 123;
+        $volume1 = new \Google_Service_Books_Volume([
+            'volumeInfo' => [
+                'imageLinks' => ['thumbnail' => '']
+            ]
+        ]);
+        $volume2 = new \Google_Service_Books_Volume([
+            'volumeInfo' => [
+                'imageLinks' => ['thumbnail' => 'testImage.jpg']
+            ]
+        ]);
+        $logger = $this->getMockBuilder('Psr\Log\LoggerInterface')->disableOriginalConstructor()->getMock();
+        $client = $this->getMock('Google_Client');
+        $client->expects($this->exactly(2))
+            ->method('getLogger')
+            ->will($this->returnValue($logger));
+        $client->expects($this->once())
+            ->method('execute')
+            ->will($this->returnValue([$volume1, $volume2]));
+        $model = $this->getMock('Google\Cloud\Samples\Bookshelf\DataModel\DataModelInterface');
+        $model->expects($this->once())
+            ->method('read')
+            ->will($this->returnValue([
+                'title' => 'My Book Title',
+            ]));
+        $model->expects($this->once())
+            ->method('update')
+            ->with(['title' => 'My Book Title', 'image_url' => 'testImage.jpg'])
+            ->will($this->returnValue(true));
+
+        $job = new LookupBookDetailsJob($model, $client);
+        $result = $job->work($bookId);
+        $this->assertTrue($result);
+    }
+}
diff --git a/test/unit/PubSub/WorkerTest.php b/test/unit/PubSub/WorkerTest.php
new file mode 100644
index 0000000..b8bd45d
--- /dev/null
+++ b/test/unit/PubSub/WorkerTest.php
@@ -0,0 +1,202 @@
+<?php
+/*
+ * Copyright 2015 Google Inc. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+namespace Google\Cloud\Samples\Bookshelf\PubSub;
+
+use Google\Cloud\PubSub\Message;
+
+class WorkerTest extends \PHPUnit_Framework_TestCase
+{
+    public function testInvoke()
+    {
+        $bookId = 123;
+        $ackId = 456;
+        $logger = $this->getMockBuilder('Psr\Log\LoggerInterface')->disableOriginalConstructor()->getMock();
+        $response = $this->getMockBuilder('Guzzle\Http\Message\Response')
+            ->disableOriginalConstructor()
+            ->getMock();
+        $response->expects($this->once())
+            ->method('getBody')
+            ->will($this->returnValue(json_encode([
+                'receivedMessages' => [
+                    [
+                        'message' => ['attributes' => ['id' => $bookId]],
+                        'ackId' => $ackId,
+                    ],
+                ]
+            ])));
+        $subscription = $this->getMockBuilder('Google\Cloud\PubSub\Subscription')
+            ->disableOriginalConstructor()
+            ->getMock();
+        $pubSubMessage = new Message(['attributes' => ['id' => $bookId]], array('ackId' => $ackId));
+        $subscription->expects($this->once())
+            ->method('acknowledgeBatch')
+            ->with([$pubSubMessage]);
+        $promise = $this->getMockBuilder('GuzzleHttp\Promise\PromiseInterface')
+            ->disableOriginalConstructor()
+            ->getMock();
+        $promise->expects($this->once())
+            ->method('then')
+            ->will($this->returnCallback(function ($callback) use ($response, $promise) {
+                // mock the returning of the response
+                $callback($response);
+                return $promise;
+            }));
+        $connection = $this->getMockBuilder('Google\Cloud\Samples\Bookshelf\PubSub\AsyncConnection')
+            ->disableOriginalConstructor()
+            ->getMock();
+        $connection->expects($this->once())
+            ->method('pull')
+            ->will($this->returnValue($promise));
+        $job = $this->getMockBuilder('Google\Cloud\Samples\Bookshelf\PubSub\LookupBookDetailsJob')
+            ->disableOriginalConstructor()
+            ->getMock();
+        $job->expects($this->once())
+            ->method('work')
+            ->with($bookId);
+        $worker = new Worker($subscription, $job, $logger);
+
+        // set the connection
+        $class = new \ReflectionClass($worker);
+        $property = $class->getProperty('connection');
+        $property->setAccessible(true);
+        $property->setValue($worker, $connection);
+
+        $timer = null; // not used
+        $worker($timer);
+    }
+
+    /**
+     * @expectedException Exception
+     * @expectedExceptionMessage Testing an exception is thrown!
+     */
+    public function testExceptionIsThrown()
+    {
+        $logger = $this->getMockBuilder('Psr\Log\LoggerInterface')->disableOriginalConstructor()->getMock();
+        $subscription = $this->getMockBuilder('Google\Cloud\PubSub\Subscription')
+            ->disableOriginalConstructor()
+            ->getMock();
+        $promise = $this->getMockBuilder('GuzzleHttp\Promise\PromiseInterface')
+            ->disableOriginalConstructor()
+            ->getMock();
+        $thenFn = function ($callback) use ($promise, &$called) {
+            throw new \Exception('Testing an exception is thrown!');
+        };
+        $promise->expects($this->once())
+            ->method('then')
+            ->will($this->returnCallback($thenFn));
+        $connection = $this->getMockBuilder('Google\Cloud\Samples\Bookshelf\PubSub\AsyncConnection')
+            ->disableOriginalConstructor()
+            ->getMock();
+        $connection->expects($this->once())
+            ->method('pull')
+            ->will($this->returnValue($promise));
+        $job = $this->getMockBuilder('Google\Cloud\Samples\Bookshelf\PubSub\LookupBookDetailsJob')
+            ->disableOriginalConstructor()
+            ->getMock();
+        $worker = new Worker($subscription, $job, $logger);
+
+        // set the connection
+        $class = new \ReflectionClass($worker);
+        $property = $class->getProperty('connection');
+        $property->setAccessible(true);
+        $property->setValue($worker, $connection);
+
+        $timer = null; // not used
+        $worker($timer);
+    }
+
+    public function testPromiseRejected()
+    {
+        $logger = $this->getMockBuilder('Psr\Log\LoggerInterface')->disableOriginalConstructor()->getMock();
+        $subscription = $this->getMockBuilder('Google\Cloud\PubSub\Subscription')
+            ->disableOriginalConstructor()
+            ->getMock();
+        $promise = $this->getMockBuilder('GuzzleHttp\Promise\PromiseInterface')
+            ->disableOriginalConstructor()
+            ->getMock();
+        $promise->expects($this->exactly(1))
+            ->method('getState')
+            ->will($this->returnValue('rejected'));
+        $promise->expects($this->exactly(1))
+            ->method('wait');
+        $job = $this->getMockBuilder('Google\Cloud\Samples\Bookshelf\PubSub\LookupBookDetailsJob')
+            ->disableOriginalConstructor()
+            ->getMock();
+        $worker = new Worker($subscription, $job, $logger);
+
+        // set the promise
+        $class = new \ReflectionClass($worker);
+        $property = $class->getProperty('promise');
+        $property->setAccessible(true);
+        $property->setValue($worker, $promise);
+
+        $timer = null; // not used
+        $worker($timer);
+    }
+
+    public function testMarkTaskComplete()
+    {
+        $logger = $this->getMockBuilder('Psr\Log\LoggerInterface')->disableOriginalConstructor()->getMock();
+        $subscription = $this->getMockBuilder('Google\Cloud\PubSub\Subscription')
+            ->disableOriginalConstructor()
+            ->getMock();
+        $promise = $this->getMockBuilder('GuzzleHttp\Promise\PromiseInterface')
+            ->disableOriginalConstructor()
+            ->getMock();
+        $thenFn = function ($callback) use ($promise, &$called) {
+            // skip the callback, mark as called
+            $called++;
+            return $promise;
+        };
+        $promise->expects($this->exactly(2))
+            ->method('then')
+            ->will($this->returnCallback($thenFn));
+        $promise->expects($this->exactly(2))
+            ->method('getState')
+            ->will($this->onConsecutiveCalls(
+                $this->returnValue('pending'),
+                $this->returnValue('fulfilled')
+            ));
+        $connection = $this->getMockBuilder('Google\Cloud\Samples\Bookshelf\PubSub\AsyncConnection')
+            ->disableOriginalConstructor()
+            ->getMock();
+        $connection->expects($this->exactly(2))
+            ->method('pull')
+            ->will($this->returnValue($promise));
+        $job = $this->getMockBuilder('Google\Cloud\Samples\Bookshelf\PubSub\LookupBookDetailsJob')
+            ->disableOriginalConstructor()
+            ->getMock();
+        $worker = new Worker($subscription, $job, $logger);
+
+        // set the connection
+        $class = new \ReflectionClass($worker);
+        $property = $class->getProperty('connection');
+        $property->setAccessible(true);
+        $property->setValue($worker, $connection);
+
+        $timer = null; // not used
+        $worker($timer);
+        $this->assertEquals(1, $called);
+
+        // call again to ensure the method is not called again
+        $worker($timer);
+        $this->assertEquals(1, $called);
+
+        $worker($timer);
+        $this->assertEquals(2, $called);
+    }
+}
diff --git a/worker.yaml b/worker.yaml
new file mode 100644
index 0000000..d788257
--- /dev/null
+++ b/worker.yaml
@@ -0,0 +1,11 @@
+runtime: php
+vm: true
+service: worker
+# [START entrypoint]
+entrypoint: php bin/pubsub/entrypoint.php
+# [END entrypoint]
+
+# [START overrides]
+env_variables:
+  PHP_INI_OVERRIDE: config/php-pubsub.ini
+# [END overrides]
